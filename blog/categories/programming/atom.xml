<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Luke Gorrie's weblog]]></title>
  <link href="http://blog.lukego.com//blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.lukego.com//"/>
  <updated>2012-10-24T17:34:50+02:00</updated>
  <id>http://blog.lukego.com//</id>
  <author>
    <name><![CDATA[Luke Gorrie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Readable programs]]></title>
    <link href="http://blog.lukego.com//blog/2012/10/24/readable-programs/"/>
    <updated>2012-10-24T17:33:00+02:00</updated>
    <id>http://blog.lukego.com//blog/2012/10/24/readable-programs</id>
    <content type="html"><![CDATA[<p>Readable programs</p>

<p>I love readable programs. I mean: programs that you can print out, take to the park, and read from top to bottom. The reason I love readable programs is that somebody has made the effort to make them readable, perhaps by the simple method of priting them out and running through them with a red pen, and this process has a simply magical effect on the clarity of the program.</p>

<p>I believe that making programs readable is the best way to improve them.</p>

<p>I gather that it used to be a common practice to print program listings and read them. I hear about it in anecdotes from programmers I admire, and I also see that many older programs appear to have been written with printing and readnig in mind: they contain pagebreak characters; they include their user-documentation in comments; and they are broken into logical sections of a couple of pages or so. The CMU AI Repository FTP server is an interesting source of 20-year-old programs like this.</p>

<p>Let me share some quotations that have stuck in my memory:</p>

<blockquote><p>The mask layout program by BillCroft at Purdue EE department - This
is a truly awesome C program that could do VLSI scale designs on a
PDP-11. The implementation included the command processing,
high-resolution graphics, and custom database. Amazingly the program
was only about half an inch thick and could be read in an afternoon.
(Contrast this to my own companies' graphics drivers for the same
device which ran ten times this for the drivers alone.)</p>

<p><i>Ward Cunningham, Wiki</i></p>

<p>I was the one who decided to rewrite the [program listing generator]
from scratch as a standalone program, partly because I wanted to add
substantial new facilities, such as the ability to list many files at
once and provide inter-file cross-references.</p>

<p><i>Guy Steele, ll1-discuss</i></p>

<p>Programming is, among other things, a kind of writing. One way to
learn writing is to write, but in all other forms of writing, one also
reads. We read examples - both good and bad - to facilitate learning.
But how many programmers learn to write programs by reading programs?
A few, but not many. And with the advent of terminals, things are
getting worse, for the programmer may not even see his own program in
a form suitable for reading. In the old days ... programmers would
while away the time by reading each others' programs. Some even went
so far as to read programs from the program library - which in those
days was still a library in the old sense of the term.</p>

<p><i>Gerald Weinberg, The Psychology of Computer Programming</i></p></blockquote>

<p>How things used to be! People measured programs in "thickness", wrote special listing generators (in 300 pages of PDP-10 assembler!), and dreaded that one day people may not sit down and read programs, not even their own. I know it's easy to feel that with our fancy IDEs we've advanced beyond such archaic ideas, but I believe instead that reading whole programs is a Good Thing.</p>

<p>I've done a few experiments with readable programs over the years. The first one was about 10 years ago, a program listing generator called pbook.el. pbook itself actually sucks - it's way too much code and way too much commentary - but regtest.erl is one reasonable example use from my professional life. I wrote another listing generator called <code>elit.el</code> that was intended to mimic Steele's style with RABBIT but this program sucked too for the same reasons. I'm not sure that listing generators are really needed, at least for short programs like bets.py. Early versions of SLIME were quietly pbook-formatted and I used to read them through without mentioning it to anybody.</p>

<p>So why blog about this now?</p>

<p>I'm working on a new project called Snabb Switch. I want the Snabb Switch code to be really good, so I'm very tempted to make it readable. I'm starting to think about what could be a practical tool for generating a program listing roughly the size of a small book, with chapters like "Intel NIC device driver", "OpenFlow forwarding engine", and so on.</p>

<p>The idea I'm playing with at the moment is to have a 'make' target to publish the Snabb Switch on leanpub. This way I can calmly read through my source code with a red pen on my train rides between Zurich and the Alps. I hope this will increased the quality of the source code overall and be well worth the effort independent of whether other people also want to write the program.</p>

<p>I've at least made one pleasing discovery: thanks to the beauty of Markdown I'm now able to write a version of pbook that is down from 241 lines to a mere 43 characters: <code>sed -E -e 's/^/    /g' -e 's/^    --- ?//g'</code> (see my <a href="https://gist.github.com/3945964">Gist</a> for details).</p>

<p>So that is my brain dump for today. Are you also interested in readable programs? Feel free to strike up a conversation with me on <code>luke@snabb.co</code>.</p>
]]></content>
  </entry>
  
</feed>
