
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Luke Gorrie's blog</title>
  <meta name="author" content="Luke Gorrie">

  
  <meta name="description" content="Snabb Switch has built-in kernel-bypass networking support. The switch is engineered as firmware and that means regarding hardware specifications on &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.lukego.com//">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Luke Gorrie's blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-33510863-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Luke Gorrie's blog</a></h1>
  
    <h2>Current mission: Develop Snabb Switch and launch it into the world</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.lukego.com/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/05/kernel-bypass-networking-in-snabb-switch/">Snabb Switch&#8217;s Kernel-bypass Networking</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-05T15:16:00+01:00" pubdate data-updated="true">Jan 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Snabb Switch has built-in <a href="http://blog.lukego.com/blog/2013/01/04/kernel-bypass-networking/">kernel-bypass networking</a> support. The switch is <a href="http://blog.lukego.com/blog/2012/10/28/firmware-vs-software/">engineered as firmware</a> and that means regarding hardware specifications on equal footing with software APIs when designing subsystems. My personal conclusion for this project is that hardware network interfaces from Intel compare favourably with software interfaces from third-party API developers.</p>

<p>Here is what makes the Snabb Switch kernel-bypass networking implementation unique:</p>

<ul>
<li>It&#8217;s special-purpose: exactly the features that benefit the application.</li>
<li>It&#8217;s written 100% from scratch, including the base ethernet device driver.</li>
<li>It&#8217;s small: about 1 KLOC of <a href="https://github.com/SnabbCo/snabbswitch/blob/master/src/intel.lua">source code</a>; about 20KB of object code.</li>
<li>It&#8217;s <a href="http://blog.lukego.com/blog/2013/01/03/snabb-switchs-luajit-ethernet-device-driver/">fast</a>: tens of millions of packets per second.</li>
<li>It supports Intel hardware: great quality in all shapes and sizes.</li>
<li>It runs on any modern Linux kernel. No kernel module or device driver needed.</li>
<li>It&#8217;s portable to other platforms: Give it access to hardware (physical RAM, raw PCI) and it takes care of everything else.</li>
<li>It&#8217;s independent. No forks to maintain, no upstreams to feed, no license fees to pay.</li>
</ul>


<p>This design suits Snabb Switch very well. In the future I foresee support for more Intel NICs, more advanced NIC features, more operating systems, and more hardware families. This will be a fun challenge over the months and years ahead.</p>

<p>Self-reliance FTW!</p>

<p>(<a href="http://www.reddit.com/r/snabb/comments/160awa/snabb_switchs_kernelbypass_networking_luke/">Comment on Snabb Switch Reddit</a>)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/04/kernel-bypass-networking/">Kernel-bypass Networking</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-04T14:13:00+01:00" pubdate data-updated="true">Jan 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Kernel-bypass networking is gaining popularity. This means moving
control of Ethernet hardware directly into userspace processes to
avoid the overhead of communicating with the operating system
kernel. This gives userspace all of the raw performance traditionally
enjoyed by the kernel &#8211; and all of the responsibility too. This is important for certain specialized applications that can gain as much as <a href="http://info.iet.unipi.it/~luigi/papers/20120503-netmap-atc12.pdf">20x more performance</a>.</p>

<p>Here is a selection of the many kernel-bypass solutions that are available:</p>

<ul>
<li><a href="http://www.ntop.org/products/pf_ring/dna/">ntop.org DNA</a>.</li>
<li><a href="http://info.iet.unipi.it/~luigi/netmap/">netmap</a>.</li>
<li><a href="http://www.intel.com/p/en_US/embedded/hwsw/technology/packet-processing">Intel DPDK</a>.</li>
<li>Myricom <a href="https://www.myricom.com/software/sniffer10g.html">Sniffer10G</a> and <a href="https://www.myricom.com/software/dbl.html">DBL</a>.</li>
<li><a href="http://www.6wind.com/6windgate-software">6WINDGate</a>.</li>
<li>SolarFlare <a href="http://www.openonload.org">OpenOnload</a>.</li>
<li><a href="http://www.napatech.com/products/network_adapters.html">Napatech</a>.</li>
</ul>


<p>These products each take their own design approaches and it&#8217;s
interesting to consider choices that they make.</p>

<ul>
<li>Customized kernel device driver. netmap and DNA both fork standard
Intel drivers with extensions to map I/O memory into userspace.</li>
<li>Custom hardware. Myricom and Napatech both distribute bespoke device drivers for their own custom hardware (ASIC for Myricom and FPGA for Napatech).</li>
<li>Userspace library. These solutions each provide unique libraries to access their extensions. The scope varies tremendously: Ethernet I/O, libpcap compatibility, hardware-assisted traffic dispatching for multiprocessing, buffer memory management, all the way up to entire TCP/IP socket layers.</li>
<li>Licensing. netmap is open-source, DNA requires a modest license for its userspace library, Napatech requires an NDA and depends on very expensive hardware.</li>
</ul>


<p>If you are developing high-speed (10+ Gbps) networking applications
then you should seriously consider using one of these solutions. If
you are an expert on one of these solutions then please tell us about
it <a href="http://www.reddit.com/r/snabb/comments/15y73y/kernelbypass_networking_luke_gorries_blog/">on the Snabb Switch Reddit</a>!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/03/snabb-switchs-luajit-ethernet-device-driver/">Snabb Switch&#8217;s LuaJIT Ethernet Device Driver</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-03T09:57:00+01:00" pubdate data-updated="true">Jan 3<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I am having fun while writing the <a href="http://www.snabb.co/snabbswitch/">Snabb Switch</a> Ethernet device driver.
This is like Intel&#8217;s standard <a href="http://sourceforge.net/projects/e1000/">E1000/IGB/IGBE driver for Linux</a> except that:</p>

<ul>
<li>It is written in <a href="http://www.luajit.org/">LuaJIT</a>. (It&#8217;s my first LuaJIT program, I&#8217;m a newbie.)</li>
<li>It runs in a normal Linux userspace process but talks directly to hardware.</li>
<li>It is tailor made for one application, a simple hypervisor-friendly ethernet switch.</li>
</ul>


<p>I have been optimizing the LuaJIT selftest code to transmit ethernet
packets in a loop. I am pretty encouraged by the performance that I
see: 3.1% CPU utilization on a low-end <a href="http://www.hetzner.de/en/hosting/produkte_rootserver/ex6">Hetzner
EX6</a> machine
to saturate a 1Gbps ethernet port with tiny packets. That is 28
nanoseconds of CPU time per packet.</p>

<p>I hope the details will be interesting. It is not so often that people
write about low-level networking in high-level dynamic programming
languages, is it? So, to give a quick taste, the driver source code is
in
<a href="https://github.com/SnabbCo/snabbswitch/blob/master/src/intel.lua">intel.lua</a>
and the selftest main loop works like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='lua'><span class='line'><span class="kd">local</span> <span class="n">deadline</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">get_time_ns</span><span class="p">()</span> <span class="o">+</span> <span class="mi">10000000000</span><span class="n">LL</span>
</span><span class='line'><span class="k">repeat</span>
</span><span class='line'>   <span class="k">while</span> <span class="n">tx_load</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.75</span> <span class="k">do</span> <span class="n">C</span><span class="p">.</span><span class="n">usleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="k">end</span>
</span><span class='line'>   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tx_available</span><span class="p">()</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">add_txbuf</span><span class="p">(</span><span class="n">dma_phys</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
</span><span class='line'>   <span class="k">end</span>
</span><span class='line'>   <span class="n">flush_tx</span><span class="p">()</span>
</span><span class='line'><span class="k">until</span> <span class="n">C</span><span class="p">.</span><span class="n">get_time_ns</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">deadline</span>
</span></code></pre></td></tr></table></div></figure>


<p>and here is what that means:</p>

<ul>
<li>Sleep while the hardware transmit queue is at least 75% full (<code>tx_load</code>).</li>
<li>Fill up the transmit queue with 60-byte packets (<code>add_txbuf</code>).</li>
<li>Tell the NIC hardware to process the transmit queue (<code>flush_tx</code>).</li>
<li>Stop after 10 seconds have elapsed (<code>get_time_ns</code>).</li>
</ul>


<p>This is all accomplished by directly controlling the NIC using
memory-mapped register I/O and DMA with shared memory. The only
operating system calls here are to sleep and check the time.</p>

<p>This is a really fun sort of programming to be doing!</p>

<p>Going forward I am really excited to see how much of a production
quality Ethernet switch can be written in a high-level dynamic
programming language, and how neatly any parts that are ultimately
written in C can be integrated into the whole. This is an open source
project and you are welcome to join in the fun too!</p>

<p>(Comments welcome <a href="http://www.reddit.com/r/snabb/comments/15vqp0/snabb_switchs_luajit_ethernet_device_driver_luke/">on the Snabb Switch Reddit</a>.)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/08/tech-mesh-2012-trip-report/">Tech Mesh 2012 Trip Report</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-08T00:15:00+01:00" pubdate data-updated="true">Dec 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I had a great time at the <a href="http://techmeshconf.com/techmesh-london-2012/">Tech Mesh</a> conference in London this week. Hearty thanks to everybody who made it happen. These are my impressions.</p>

<p>Stuart Bailey&#8217;s talk was heartwarming. He&#8217;s an Erlang guy who&#8217;s finally meeting other Erlang people in the flesh. &#8220;Honey, you wouldn&#8217;t believe it, I can talk about Erlang here and they don&#8217;t look at me like I&#8217;m crazy.&#8221; I think it&#8217;s a beautiful moment that many of us can relate to.</p>

<p>Amazingly, Lisp code was on screens all over the place with no fuss being made whatsoever. This was all Clojure. Rich Hickey was there. I&#8217;d heard him speak once before, five years ago at the Lisp 50th anniversary event at OOPSLA, where everybody looked to him as the great hope to give Lisp a fresh start. Looks to me like he has delivered on what he promised. Great work Rich! That is no small feat.</p>

<p>I met a lot of friendly and interesting people. Haskell hackers, Xen hackers, even another Queenslander like me. I found the boyish enthusiasm of Simon Peyton Jones and Joe Armstrong very infectious, as always. I was also really glad to meet up with a lot of my old friends from the Stockholm Erlang scene.</p>

<p>The language runtime panel reminded me of one idea that&#8217;s been rattling around in my head forever. Take it as given that (a) the Erlang VM is great for concurrency because it gives you efficient process isolation and (b) hardware advances are making the Linux kernel&#8217;s process isolation more efficient every year. So when will it be time to start using the Linux kernel as an Erlang-like language runtime environment? If you strip away all the layers of crud on top, are we already there? This seems like valid research question.</p>

<p>I like the overall conference theme of helping to introduce niche ideas to a wider group of people. I am a bit outside the target demographic myself. Tech Mesh is full of ideas with ten thousand devotees trying to spread themselves to the next million. I am more comfortable with the smaller memes myself, when everybody thinks you are mad and you have to work hard to convince the first ten or hundred people that you&#8217;re not. That is why I am working on high-performance networking firmware in userspace with LuaJIT device drivers. I suppose everybody has their own ideal proximity to mainstream thinking and that every technology is a moving target in that respect.</p>

<p>The organization was great. Plentiful food, coffee, and other beverages. A bit chilly but hey, this is England. The venue was right near the British Museum so I finally saw the Rosetta Stone for the first time. Thanks everybody!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/28/firmware-vs-software/">Firmware vs. Software</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-28T13:01:00+01:00" pubdate data-updated="true">Oct 28<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Firmware is great stuff. It&#8217;s the same as software and at the same
time it&#8217;s different. It&#8217;s a bit like visible and ultraviolet light:
they are fundamentally the same &#8220;stuff&#8221; but they are on different
parts of the spectrum.</p>

<ol>
<li>Firmware compiles to a self-contained image. The build process creates this one file and it has no external dependencies. There is a specific piece of hardware that can execute the image file.</li>
<li>Firmware has known space targets. They are usually measured in kilobytes. You always keep an eye on how much of your ROM and RAM budgets are used up.</li>
<li>Firmware is intimate with hardware. You don&#8217;t use libraries and frameworks, you control microchips. Your documentation is hardware data sheets and errata lists. Your job is to understand the hardware completely and make it sing.</li>
<li>Firmware is self-reliant. You take responsibility for every byte you ship in your image. That means being prepared to study and learn to debug any code that you choose to reuse. You always keep an eye on the total transitive complexity of the code you depend on.</li>
</ol>


<p>My favorite piece of firmware is <a href="http://www.openfirmware.info/Open_Firmware">Openfirmware</a>. This is shipped on a 1MB ROM chip in the <a href="http://en.wikipedia.org/wiki/OLPC_XO-1">OLPC XO</a> instead of a traditional BIOS. It&#8217;s a complete and self-sufficient software environment that has been carefully crafted over the past few decades by super-hacker <a href="http://howsoftwareisbuilt.com/2008/03/27/interview-with-mitch-bradley-firmware-olpc/">Mitch Bradley</a>. If you have an OLPC XO and would like to learn about firmware then I can recommend studying Mitch&#8217;s <a href="http://wiki.laptop.org/go/Forth_Lessons">Forth Lessons</a>.</p>

<p>These days we can choose to deploy our applications as firmware, software, and increasingly as full-scale OS distributions &#8211; kilobytes, megabytes, or gigabytes. There is sometimes one style that&#8217;s clearly the best and other times several options are all reasonable choices.</p>

<p>Firmware is fun and refreshing to write. I have chosen to develop my new <a href="http://www.github.com/SnabbCo/snabbswitch/">Snabb Switch</a> project as firmware. I will post a lot more about the implications of this decision over time.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/24/readable-programs/">Readable Programs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-24T17:33:00+02:00" pubdate data-updated="true">Oct 24<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I love readable programs. I mean: programs that you can print out, take to the park, and read from top to bottom. The reason I love readable programs is that somebody has made the effort to make them readable, perhaps simply by priting them out and running through them with a red pen a few times, and I believe this simple process to have a magical effect on a program&#8217;s clarity.</p>

<p>I believe that making programs readable is one of the best and easiest ways to improve them.</p>

<p>I gather that it used to be a common practice to print program listings and read them. I hear about it in anecdotes from programmers I respect, and I also see that many older programs appear to have been written with printing and readnig in mind: they contain pagebreak characters; they include their user-documentation in comments; and they are broken into logical sections of a couple of pages or so.</p>

<p>Let me share some quotations that have stuck in my memory:</p>

<blockquote><p>The mask layout program by BillCroft at Purdue EE department - This
is a truly awesome C program that could do VLSI scale designs on a
PDP-11. The implementation included the command processing,
high-resolution graphics, and custom database. Amazingly the program
was only about half an inch thick and could be read in an afternoon.
(Contrast this to my own companies&#8217; graphics drivers for the same
device which ran ten times this for the drivers alone.)</p></blockquote>

<p>&#8211; <a href="http://c2.com/cgi/wiki?PleaseShowMeAlargeWellFactoredProgram">Ward Cunningham, WardsWiki</a></p>

<blockquote><p>I was the one who decided to rewrite the [program listing generator]
from scratch as a standalone program, partly because I wanted to add
substantial new facilities, such as the ability to list many files at
once and provide inter-file cross-references.</p></blockquote>

<p>&#8211; <a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg02724.html">Guy Steele, ll1-discuss</a></p>

<blockquote><p>Programming is, among other things, a kind of writing. One way to
learn writing is to write, but in all other forms of writing, one also
reads. We read examples - both good and bad - to facilitate learning.
But how many programmers learn to write programs by reading programs?
A few, but not many. And with the advent of terminals, things are
getting worse, for the programmer may not even see his own program in
a form suitable for reading. In the old days &#8230; programmers would
while away the time by reading each others&#8217; programs. Some even went
so far as to read programs from the program library - which in those
days was still a library in the old sense of the term.</p></blockquote>

<p>&#8211; <a href="http://www.amazon.com/The-Psychology-Computer-Programming-Anniversary/dp/0932633420">Gerald Weinberg, The Psychology of Computer Programming</a></p>

<p>How different things used to be. People measured programs in &#8220;thickness&#8221;, wrote special listing generators (in <a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg02718.html">300 pages of PDP-10 assembler</a> - quite an effort), and dreaded that one day people may not sit down and read programs, not even their own.</p>

<p>I know it&#8217;s easy to feel that with our fancy IDEs we&#8217;ve advanced beyond such archaic ideas, but I believe that reading whole programs is a Good Thing and worth holding on to.</p>

<p>I&#8217;ve done a few experiments with readable programs over the years. The first one was about 10 years ago, a program listing generator called <a href="http://discontinuity.info/~pkhuong/pbookc.pdf">pbook.el</a>. pbook itself actually sucks - it&#8217;s way too much code and way too much commentary - but <a href="http://fresh.homeunix.net/~luke/misc/erlang/regtest.pdf">regtest.erl</a> is one reasonable example use from my professional life. I wrote another listing generator called <code>elit.el</code> that was intended to mimic Steele&#8217;s style with RABBIT but this program sucked too for the same reasons. I&#8217;m not sure that listing generators are really needed, at least for short programs like <a href="http://fresh.homeunix.net/~luke/misc/python/bets.py.txt">bets.py</a>. Early versions of <a href="http://en.wikipedia.org/wiki/SLIME">SLIME</a> were quietly pbook-formatted and I used to read them through without mentioning it to anybody.</p>

<p>So why blog about this now?</p>

<p>I&#8217;m working on a new project called <a href="http://www.github.com/SnabbCo/snabbswitch/">Snabb Switch</a>. I want the Snabb Switch code to be really good, so I&#8217;m very tempted to make it readable. I&#8217;m starting to think about what could be a practical tool for generating a program listing roughly the size of a small book, with chapters like &#8220;Intel NIC device driver&#8221;, &#8220;OpenFlow forwarding engine&#8221;, and so on.</p>

<p>The idea I&#8217;m playing with at the moment is to have a &#8216;make&#8217; target to publish the Snabb Switch on <a href="http://www.leanpub.com/">Leanpub</a>. This way I can calmly read through my source code with a red pen on my train rides between Zurich and the Alps. I expect that this would increase the quality of my source code overall and be well worth the effort, quite independent of whether other people decide to read the program too.</p>

<p>I&#8217;ve at least made one pleasing discovery: thanks to the beauty of Markdown I&#8217;m now able to write a version of pbook that is down from 241 lines to a mere 43 characters: <code>sed -E -e 's/^/    /g' -e 's/^    --- ?//g'</code>. (See my <a href="https://gist.github.com/3945964">Gist</a> for a few more details.)</p>

<p>So that is my brain dump for today. Are you also interested in readable programs? Feel free to strike up a conversation with me on <code>luke@snabb.co</code>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/25/lukes-highly-opinionated-programming-language-roundup-2012/">Luke&#8217;s Highly Opinionated Programming Language Roundup 2012</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-25T11:26:00+02:00" pubdate data-updated="true">Sep 25<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Hoi Z&auml;me!</p>

<p>This post is a tribute to the <a href="http://emerginglangs.com">Emerging Languages conference</a> that I just missed. I&#8217;ve started a new project called <a href="http://www.github.com/SnabbCo/snabbswitch">Snabb Switch</a> and this is a braindump on how I&#8217;m choosing which programming language to use.</p>

<p>The Snabb Switch project is a low-level networking stack with emphasis on hypervisors. The #1 technical requirement is that you&#8217;re receiving a packet every microsecond or so and you have to do something clever with it and ship it back out quickly. I have a background of real programming in a bunch of languages: C, Erlang, Common Lisp, Scheme, Forth, Smalltalk, Emacs Lisp, Java, and the usual Unix suspects. I have the engineering philosophy of a firmware developer: I appreciate minimalism and I don&#8217;t want to depend on software that I&#8217;m not willing to understand and debug (less is more). I want to faithfully follow my own engineering values and simultaneously make the project accessible to other interested people.</p>

<p>Here are the languages on my radar for this project and a raw dump of my thoughts on them:</p>

<p>C. In my mind some code just is morally C code, no matter what language it&#8217;s written in, and other code morally is not C. I like to use C for code that&#8217;s morally C, like device drivers and packet shuffling, but I don&#8217;t want to use C for stuff that&#8217;s morally high-level, like configuration and status reporting and scripting. So I&#8217;m only happy to use C for problems that are 100% low-level or otherwise in a cocktail with a higher-level language.</p>

<p>C++. I am impressed when I see people use C++ to overcome the limitations of C and find clever ways to write whole applications. They win the ICFP programming contest pretty often and that impresses me. My gut feeling though is that this works well in tight organisations like Google but that C++ is a barrier to entry in more loosely coupled open source projects. The language also has a bit of a corporate feel to me &#8211; I&#8217;ve never picked up a C++ book just for fun. The C hacker in me is jealous the good collection of basic data structures though.</p>

<p>Objective-C. This is another chance to keep what&#8217;s good about C and overcome the limitations. I don&#8217;t want to commit to OSX as the target platform though &#8211; I&#8217;m focused on Linux and open to Windows &#8211; and I&#8217;m not confident that it&#8217;s portable in practice.</p>

<p>Erlang. I have done a <i>lot</i> of Erlang programming over the years and I know that it&#8217;s really excellent for a wide range of problems. I don&#8217;t want to use it for this project though. Erlang isn&#8217;t the right tool for writing morally-C code, and I haven&#8217;t really enjoyed using the FFI (linked-in drivers) in the past. I also feel that the Erlang runtime system is a really scary program these days &#8211; I don&#8217;t want to have to chase through it with gdb when hunting really tough bugs.</p>

<p><a href="http://www.sbcl.org/">SBCL</a>. Common Lisp is an extremely interesting option and one that I&#8217;ve <a href="http://lisp-univ-etc.blogspot.ch/2012/07/lisp-hackers-luke-gorrie-his-eclm-video.html">explored in depth previously</a>. You can write morally-C code in Common Lisp, but I feel like you <a href="http://www.paulgraham.com/carl.html">have to work really hard</a> when you do this, and I prefer to do my bit-bashing in C. CFFI is not quite convenient enough to make this fun for me in day to day usage. The SBCL runtime system is also of a similar complexity level to Erlang and I&#8217;ve found that it interacts badly with tools like strace and gdb. I don&#8217;t want to be chasing weird bugs involving e.g. signal handlers waking up when I write to memory that the GC has write-protected etc.</p>

<p><a href="http://ecls.sourceforge.net">Embedded Common Lisp (ECL)</a>. Is this a Lisp with a dream-like FFI and minimalist runtime system? I&#8217;m not sure, it sounds a bit too good to be true, and I haven&#8217;t investigated because I don&#8217;t have a specific agenda to use Lisp. I would love to hear from people who have experience building systems comparable to Snabb Switch in ECL.</p>

<p><a href="http://www.openfirmware.info/Open_Firmware">Openfirmware</a>. Mitch Bradley&#8217;s Openfirmware Forth system is a masterpiece and in many ways very well suited to my project. Compact size, good mix of high-level (bytecode) and low-level (inline assembler), minimal and predictable runtime system, suitable for writing morally-C code. I reckon that Openfirmware based network equipment would work extremely well, but I also reckon that very few people could build such systems in a realistic amount of time. Forth is also naturally a barrier to adoption: it&#8217;s tricky to get the hang of and the study of Forth feels more like advanced computer science than basic engineering. So rather than use Forth I will seek out other tools that are acceptable to my inner Forth programmer.</p>

<p><a href="http://www.luajit.org/">LuaJIT</a>. Wow! Lots of positive points. The whole implementation is small and simple. The runtime system is minimal and leaves me space to make important decisions like whether to use threads and how. The FFI is the best I&#8217;ve ever seen &#8211; it makes it easy to talk directly to hardware via shared memory and easy to call into C libraries. I can use a lovely workflow where morally-C code is initially written in LuaJIT and be selectively rewritten in C over time. The JIT is creating its own machine code in Forth-hacker real programmer style &#8211; I don&#8217;t understand it but I <em>want</em> to, and its small implementation makes this seem realistic. And there&#8217;s a <a href="http://www.freelists.org/post/luajit/LuaJIT-in-realtime-applications,3">reasonable story on soft realtime</a>.</p>

<p>So: I&#8217;ve started off using LuaJIT and C. Initially the code is mostly LuaJIT but I do feel like I&#8217;m comfortably able to move the LuaJIT-C border around to see where it feels the best. This feels comfortable for the parts of my soul that love C, Forth, Scheme, and Emacs Lisp. The bits of my soul that love Erlang, Common Lisp, and Smalltalk will have to be patient :-).</p>

<p>I will blog about how it goes over time. If you want to discuss this stuff in more depth feel free to email me on <tt>luke@snabb.co</tt>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/08/02/nehalem-i-slash-o-performance/">Intel&#8217;s Performance Counter Monitor</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-02T17:33:00+02:00" pubdate data-updated="true">Aug 2<span>nd</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Wanna find the limiting factor in I/O performance on an Intel Nehalem server app? Here&#8217;s one idea.</p>

<p>The Nehalem architecture looks like this:<br>
<a href="http://www.qdpma.com/SystemArchitecture/SystemArchitecture_QPI.html">
<img src="/images/Xeon5500_1IOH.png" alt="Nehalem Architecture" />
</a></p>

<p>So the main potential bottlenecks are:</p>

<ol>
<li>RAM<->CPU @ approx 256Gbps to each CPU&#8217;s RAM bank. (Too many memory copies?)</li>
<li>CPU<->CPU @ approx 200Gbps for sharing RAM over <a href="http://en.wikipedia.org/wiki/Intel_QuickPath_Interconnect">QPI</a>. (NUMA all mucked up?)</li>
<li>PCIe @ approx 72Gbps. (Out of ports? Crappy motherboard?)</li>
<li>Storage disk/SSD. (Waiting all the time?)</li>
</ol>


<p>Intel&#8217;s <a href="http://software.intel.com/en-us/articles/intel-performance-counter-monitor/">Performance Counter Monitor</a> can tell you the utilization of these links. It&#8217;s like <code>top</code> for memory bandwidth, inter-processor data shuffling, PCIe load, etc. I used this tool for verifying that PCs can push 40Gbps of full-duplex ethernet traffic without any hassle. Intel make some really fine tech.</p>

<p>Give it a try! It&#8217;s really easy to install.</p>

<p>Here&#8217;s how it looks:</p>

<pre>
 EXEC  : instructions per nominal CPU cycle
 IPC   : instructions per CPU cycle
 FREQ  : relation to nominal CPU frequency='unhalted clock ticks'/'invariant timer ticks' (includes Intel Turbo Boost)
 AFREQ : relation to nominal CPU frequency while in active state (not in power-saving C state)='unhalted clock ticks'/'invariant timer ticks while in C0-state'  (includes Intel Turbo Boost)
 L3MISS: L3 cache misses 
 L2MISS: L2 cache misses (including other core's L2 cache *hits*) 
 L3HIT : L3 cache hit ratio (0.00-1.00)
 L2HIT : L2 cache hit ratio (0.00-1.00)
 L3CLK : ratio of CPU cycles lost due to L3 cache misses (0.00-1.00), in some cases could be >1.0 due to a higher memory latency
 L2CLK : ratio of CPU cycles lost due to missing L2 cache but still hitting L3 cache (0.00-1.00)
 READ  : bytes read from memory controller (in GBytes)
 WRITE : bytes written to memory controller (in GBytes)


 Core (SKT) | EXEC | IPC  | FREQ  | AFREQ | L3MISS | L2MISS | L3HIT | L2HIT | L3CLK | L2CLK  | READ  | WRITE 

   0    0     0.59   0.60   0.98    1.00    1743 K   3978 K    0.56    0.62    0.15    0.07     N/A     N/A
   1    0     0.61   0.62   0.97    1.00    2595 K   3356 K    0.23    0.64    0.23    0.02     N/A     N/A
   2    0     0.49   0.59   0.83    1.00    2205 K   3198 K    0.31    0.60    0.22    0.03     N/A     N/A
   3    0     0.06   0.32   0.18    1.00     715 K    921 K    0.22    0.35    0.34    0.02     N/A     N/A
------------------------------------------------------------------------------------------------------------
 TOTAL  *     0.43   0.59   0.74    1.00    7259 K     11 M    0.37    0.61    0.21    0.04    6.51    2.85

 Instructions retired: 3707 M ; Active cycles: 6317 M ; Time (TSC): 2134 Mticks ; C0 (active,non-halted) core residency: 73.99 %

 PHYSICAL CORE IPC                 : 0.59 => corresponds to 14.67 % utilization for cores in active state
 Instructions per nominal CPU cycle: 0.43 => corresponds to 10.86 % core utilization over time interval
----------------------------------------------------------------------------------------------
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/08/shared-memory-a-moment-of-appreciation/">Shared Memory: A Moment of Appreciation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-08T03:46:00+02:00" pubdate data-updated="true">Jul 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Today I&#8217;m feeling appreciative of <a href="http://en.wikipedia.org/wiki/Shared_memory">shared memory</a>.</p>

<p>There are a lot of communication mechanisms in widespread use: C APIs, system calls, RESTful services, JSON-RPC, AMQP, and plenty more besides. Some mechanisms survive, a lot influence new successors, and quite a lot of them just fall out of fashion and turn to dust. Shared memory is one with a timeless quality. Year after year it&#8217;s the glue that holds our computers together.</p>

<p>Shared memory is a simple mechanism. Many different programs are concurrently accessing the physical RAM chips in the ocmputer. The programs are written in completely different programming languages, they are executing on different microchips, and some of them are implemented as hardware rather than software. The programs all share a common abstraction: LOAD and STORE operations towards a big array of machine words. The rest is a matter of conventions, design patterns, and data structures. That&#8217;s all we need!</p>

<p>I really enjoy the versatility. How sweet it is to be able to drive hardware memory controller so directly.</p>

<h3>Playing around</h3>

<p>Just for fun, here&#8217;s a shared memory interface I&#8217;m playing with for ethernet networking. That is: to use shared memory to send and receive packets between a &#8220;host&#8221; and a &#8220;device&#8221;. The host and device can be written in any programming language, or indeed in hardware, and this is roughly how hardware packet I/O interfaces really look.</p>

<p>Here&#8217;s an example memory layout. I sketched it using C syntax and defined a packet <a href="http://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a> for transmision in each direction.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">RING_SIZE</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PACKET_SIZE</span> <span class="o">=</span> <span class="mi">1504</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// One ethernet packet.</span>
</span><span class='line'><span class="k">struct</span> <span class="n">packet</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>         <span class="c1">// length of packet</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">PACKET_SIZE</span><span class="p">];</span>      <span class="c1">// on-the-wire packet data</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Ring buffer containing ethernet packets.</span>
</span><span class='line'><span class="k">struct</span> <span class="n">ring</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>           <span class="c1">// position of first unread packet</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>           <span class="c1">// position of last unread packet</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overflow_count</span><span class="p">;</span> <span class="c1">// number of packets dropped due to overflow</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">packet</span> <span class="n">packets</span><span class="p">[</span><span class="n">RING_SIZE</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Ethernet device with two ring buffers for transmit and receive.</span>
</span><span class='line'><span class="k">struct</span> <span class="n">dev</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>          <span class="c1">// magic number identifying the structure</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>        <span class="c1">// version of memory layout</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">ring</span> <span class="n">dev2host</span><span class="p">;</span>        <span class="c1">// ring of packets from host to device</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">ring</span> <span class="n">host2dev</span><span class="p">;</span>        <span class="c1">// ring of packets from device to host</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here&#8217;s a snippet using the data structure from C:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring</span> <span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>and here&#8217;s a snippet from LuaJIT:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='lua'><span class='line'><span class="k">function</span> <span class="nf">is_full</span> <span class="p">(</span><span class="n">ring</span><span class="p">)</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">ring</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="p">(</span><span class="n">ring</span><span class="p">.</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">C</span><span class="p">.</span><span class="n">RING_SIZE</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>and with any luck I&#8217;ll find an excuse to see how it looks in a hardware description language like Verilog too.</p>

<p>That&#8217;s all. I really appreciate shared memory. Hardware people use it all the time. It&#8217;s not the most high level communication protocol around, but it is simple and accessible, and it can be fun for software people too. I think so, anyway :-)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/07/new-blog/">New Blog!</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-07T03:56:00+02:00" pubdate data-updated="true">Jul 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>New blog! This time I&#8217;m taking Octopress for a spin. I really like the idea of markdown for text and static generation of content. Reminds me a bit of using <a href="http://www.latte.org/latte.html" title="Latte">Latte</a> in the old days. Latte became a dead-end when bitrot set in on the toolchain for generating pages. Let&#8217;s see how this goes.</p>

<p>I&#8217;ve made a homepage <a href="http://lukego.com/">lukego.com</a> now to keep track of my comings and goings and my old blog was <a href="http://lukego.livejournal.com/">lukego.livejournal.com</a>.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Check me out!</h1>
  <p>
    Personal: <a href="http://www.lukego.com/">My homepage</a><br/>
    Hacking: <a href="http://www.github.com/SnabbCo/snabbswitch">Snabb Switch</a><br/>
    Professional: <a href="http://www.snabb.co/">Snabb</a>
    <a href="http://www.snabb.co/"><img src="http://www.snabb.co/Tiger_snabb_128.png" alt="Snabb logo"/></a>
  </p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/01/05/kernel-bypass-networking-in-snabb-switch/">Snabb Switch&#8217;s kernel-bypass networking</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/04/kernel-bypass-networking/">Kernel-bypass networking</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/03/snabb-switchs-luajit-ethernet-device-driver/">Snabb Switch&#8217;s LuaJIT Ethernet device driver</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/08/tech-mesh-2012-trip-report/">Tech Mesh 2012 Trip Report</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/28/firmware-vs-software/">Firmware vs. Software</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("lukego", 5, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/lukego" class="twitter-follow-button" data-show-count="false">Follow @lukego</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Luke Gorrie -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
